import { __decorate, __metadata } from "tslib";
import { OnDestroy, OnInit, OnChanges, EventEmitter, ElementRef, Input, Output, SimpleChanges, Directive } from '@angular/core';
import * as Chart from 'chart.js';
import { StoreService } from './store.service';
import { NgChartjsService } from './ng-chartjs.service';
import { getColors } from './colors';
/* tslint:disable-next-line */
import * as ɵngcc0 from '@angular/core';
let NgChartjsDirective = class NgChartjsDirective {
    constructor(element, ngChartjsService, storeService) {
        this.ngChartjsService = ngChartjsService;
        this.storeService = storeService;
        // x轴标签。这对图表来说是必要的：线，条和雷达。并且只是图表的标签（悬停）：polarArea，pie和doughnut
        this.labels = [];
        // 相当于chart.js的option
        this.options = {};
        // 鼠标点击图表所有的区域
        this.chartClick = new EventEmitter();
        // 鼠标悬浮在标签或者活跃的点上面时
        this.chartHover = new EventEmitter();
        this.initFlag = false;
        this.hasChanges = false;
        this.element = element; // 获取指令所在canvas元素
    }
    ngOnInit() {
        this.ctx = this.element.nativeElement.getContext('2d'); // 获取元素的ctx
        this.initFlag = true; // 是否初始化了的标志
        if (this.data || this.datasets) { // 判断data和datasets有一个有数据就刷新
            this.refresh();
        }
    }
    ngOnChanges(changes) {
        // TODO: 插件变化刷新，开放刷新按钮
        if (this.initFlag) {
            // Check if the changes are in the data or datasets
            if (changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) {
                if (changes.data) {
                    this.updateChartData(changes.data.currentValue);
                }
                else {
                    this.updateChartData(changes.datasets.currentValue);
                }
                this.hasChanges = true;
            }
            if (changes.hasOwnProperty('labels')) {
                this.chart_.data.labels = changes.labels.currentValue;
                this.hasChanges = true;
            }
            if (changes.hasOwnProperty('legend')) {
                if (changes.legend.currentValue !== changes.legend.previousValue) {
                    this.chart_.options.legend.display = changes.legend.currentValue;
                    this.hasChanges = true;
                }
            }
            if (changes.hasOwnProperty('adding')) {
                this.addData_(changes.adding.currentValue.labels, changes.adding.currentValue.data);
                this.hasChanges = true;
            }
            if (changes.hasOwnProperty('removing')) {
                if (changes.removing.currentValue.orientation === 'oldest' || changes.removing.currentValue.orientation === 'latest') {
                    this.removeData_(changes.removing.currentValue.orientation);
                    this.hasChanges = true;
                }
            }
            if (changes.hasOwnProperty('chartType')) {
                this.refresh();
            }
            if (changes.hasOwnProperty('resetOption')) {
                Object.assign(this.chart_.options, changes.resetOption.currentValue);
                this.hasChanges = true;
            }
            if (this.hasChanges) {
                this.chart_.update();
                this.hasChanges = false;
            }
        }
    }
    ngOnDestroy() {
        if (this.chart_) {
            this.chart_.destroy();
            this.chart_ = void 0;
            if (this.element.nativeElement.hasAttribute('id')) {
                this.storeService.removeChart(this.element.nativeElement.id); // delete chart instance.
            }
        }
    }
    // get Chartjs object
    get chart() { return this.chart_; }
    // update chartjs
    update() {
        this.chart_.update();
    }
    // Dynamic add data
    addData(labels, data) {
        this.addData_(labels, data);
        this.update();
    }
    // Dynamic remove data, orientation is 'ildest' or 'latest'
    removeData(orientation) {
        this.removeData_(orientation);
        this.update();
    }
    refresh() {
        this.ngOnDestroy();
        this.chart_ = this.getChartBuilder(this.ctx /*, data, this.options*/);
        if (this.element.nativeElement.hasAttribute('id')) {
            this.storeService.addChart(this.element.nativeElement.id, this.chart_);
        }
    }
    updateChartData(newDataValues) {
        if (Array.isArray(newDataValues[0].data)) {
            this.chart_.data.datasets.forEach((dataset, i) => {
                dataset.data = newDataValues[i].data;
                if (newDataValues[i].label) {
                    dataset.label = newDataValues[i].label;
                }
            });
        }
        else {
            this.chart_.data.datasets[0].data = newDataValues;
        }
    }
    getChartBuilder(ctx /*, data:Array<any>, options:any*/) {
        const datasets = this.getDatasets();
        const options = Object.assign({}, this.options); // 深复制options
        if (this.legend === false) { // 设置options的legend TODO: 后续这个属性去除，直接在options内设置
            options.legend = { display: false };
        }
        // hock for onHover and onClick events
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = (event, active) => {
                if (active && !active.length) {
                    return;
                }
                this.chartHover.emit({ event, active });
            };
        }
        if (!options.onClick) {
            options.onClick = (event, active) => {
                this.chartClick.emit({ event, active });
            };
        }
        const opts = {
            type: this.chartType,
            data: {
                labels: this.labels,
                datasets: datasets // TODO: 后续更改这个属性名字，否则警告
            },
            options: options,
            plugins: this.inlinePlugins
        };
        return new Chart(ctx, opts);
    }
    // 获取 chart.js的datasets数据
    getDatasets() {
        let datasets = void 0;
        // in case if datasets is not provided, but data is present
        if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {
            if (Array.isArray(this.data[0])) {
                datasets = this.data.map((data, index) => {
                    return { data, label: this.labels[index] || `Label ${index}` };
                });
            }
            else {
                datasets = [{ data: this.data, label: `Label 0` }];
            }
        }
        if (this.datasets && this.datasets.length || (datasets && datasets.length)) {
            // fix elm type, pre type is number
            datasets = (this.datasets || datasets).map((elm, index) => {
                const newElm = Object.assign({}, elm);
                if (this.colors && this.colors.length) {
                    Object.assign(newElm, this.colors[index]);
                }
                else {
                    Object.assign(newElm, getColors(this.chartType, index, newElm.data.length));
                }
                return newElm;
            });
        }
        if (!datasets) {
            throw new Error(`ng-chartjs configuration error,
      data or datasets field are required to render char ${this.chartType}`);
        }
        return datasets;
    }
    addData_(labels, data) {
        if (labels.length === 0 || data.length === 0) {
            return;
        }
        // update labels
        labels.forEach((label) => { this.chart_.data.labels.push(label); });
        this.chart_.data.datasets.forEach((dataset, index) => {
            if (data[index]) {
                for (let i = 0; i < data[index].length; i++) {
                    dataset.data.push(data[index][i]);
                }
            }
            else {
                console.log('The added data does not match the original data');
                return;
            }
        });
    }
    removeData_(orientation) {
        // fix: support to oldest feature
        if (orientation === 'latest') {
            this.chart_.data.labels.pop();
            this.chart_.data.datasets.forEach((dataset) => {
                dataset.data.pop();
            });
        }
        else if (orientation === 'oldest') {
            this.chart_.data.labels.shift();
            this.chart_.data.datasets.forEach((dataset) => {
                dataset.data.shift();
            });
        }
    }
};
NgChartjsDirective.ɵfac = function NgChartjsDirective_Factory(t) { return new (t || NgChartjsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgChartjsService), ɵngcc0.ɵɵdirectiveInject(StoreService)); };
NgChartjsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgChartjsDirective, selectors: [["canvas", "ngChartjs", ""]], inputs: { labels: "labels", options: "options", data: "data", datasets: "datasets", inlinePlugins: "inlinePlugins", chartType: "chartType", colors: "colors", legend: "legend", adding: "adding", removing: "removing", resetOption: "resetOption" }, outputs: { chartClick: "chartClick", chartHover: "chartHover" }, exportAs: ["ngChartjs"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NgChartjsDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgChartjsService },
    { type: StoreService }
];
__decorate([
    Input(),
    __metadata("design:type", Array)
], NgChartjsDirective.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NgChartjsDirective.prototype, "datasets", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NgChartjsDirective.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgChartjsDirective.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NgChartjsDirective.prototype, "inlinePlugins", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NgChartjsDirective.prototype, "chartType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NgChartjsDirective.prototype, "colors", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NgChartjsDirective.prototype, "legend", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgChartjsDirective.prototype, "adding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgChartjsDirective.prototype, "removing", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NgChartjsDirective.prototype, "resetOption", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NgChartjsDirective.prototype, "chartClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NgChartjsDirective.prototype, "chartHover", void 0);
NgChartjsDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        NgChartjsService,
        StoreService])
], NgChartjsDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgChartjsDirective, [{
        type: Directive,
        args: [{ selector: 'canvas[ngChartjs]', exportAs: 'ngChartjs' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NgChartjsService }, { type: StoreService }]; }, { labels: [{
            type: Input
        }], options: [{
            type: Input
        }], chartClick: [{
            type: Output
        }], chartHover: [{
            type: Output
        }], data: [{
            type: Input
        }], datasets: [{
            type: Input
        }], inlinePlugins: [{
            type: Input
        }], chartType: [{
            type: Input
        }], colors: [{
            type: Input
        }], legend: [{
            type: Input
        }], adding: [{
            type: Input
        }], removing: [{
            type: Input
        }], resetOption: [{
            type: Input
        }] }); })();
export { NgChartjsDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctY2hhcnRqcy5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIm5nOi9uZy1jaGFydGpzL2xpYi9uZy1jaGFydGpzLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxNQUFNLEVBQ04sU0FBUyxFQUNULFlBQVksRUFDWixVQUFVLEVBQ1YsS0FBSyxFQUNMLE1BQU0sRUFDTixhQUFhLEVBQ2IsU0FBUyxFQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sS0FBSyxLQUFLLE1BQU0sVUFBVSxDQUFDO0FBQ2xDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsU0FBUyxFQUFVLE1BQU0sVUFBVSxDQUFDO0FBTTdDLDhCQUE4Qjs7QUFFOUIsSUFBYSxrQkFBa0IsR0FBL0IsTUFBYSxrQkFBa0I7SUFtQzdCLFlBQW1CLE9BQW1CLEVBQzVCLGdCQUFrQyxFQUNsQyxZQUEwQjtRQUQxQixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ2xDLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBL0JwQyw4REFBOEQ7UUFDckQsV0FBTSxHQUFXLEVBQUUsQ0FBQztRQUM3QixxQkFBcUI7UUFDWixZQUFPLEdBQXVCLEVBQUUsQ0FBQztRQWMxQyxjQUFjO1FBQ0osZUFBVSxHQUFpQyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ3hFLG1CQUFtQjtRQUNULGVBQVUsR0FBaUMsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUloRSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFPekIsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBRyxpQkFBaUI7SUFDN0MsQ0FBQztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFP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aUI7QUFFaEI7SUFBUixLQUFLLEVBQUU7O2tEQUE2QztBQUM1QztJQUFSLEtBQUssRUFBRTs7b0RBQXdDO0FBQ3ZDO0lBQVIsS0FBSyxFQUFFOzt1REFBOEI7QUFHNUI7SUFBVCxNQUFNLEVBQUU7OEJBQWEsWUFBWTtzREFBc0M7QUFFOUQ7SUFBVCxNQUFNLEVBQUU7OEJBQWEsWUFBWTtzREFBc0M7QUExQjdELGtCQUFrQixlQUFlLEtBRDdDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSwzQkFDbkIsa0NBbUMwQixVQUFVO0FBcENFLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBRSxqQkFxQ3JDLGdCQUFnQjtBQXJDc0IsUUFzQzFDLFlBQVk7R0FyQ3pCLGtCQUFrQixDQW9ROUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFDRDtTQXJRYSxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT25DaGFuZ2VzLFxuICBFdmVudEVtaXR0ZXIsXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIERpcmVjdGl2ZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIENoYXJ0IGZyb20gJ2NoYXJ0LmpzJztcbmltcG9ydCB7IFN0b3JlU2VydmljZSB9IGZyb20gJy4vc3RvcmUuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NoYXJ0anNTZXJ2aWNlIH0gZnJvbSAnLi9uZy1jaGFydGpzLnNlcnZpY2UnO1xuaW1wb3J0IHsgZ2V0Q29sb3JzLCBDb2xvcnMgfSBmcm9tICcuL2NvbG9ycyc7XG5cbmV4cG9ydCB0eXBlIExhYmVscyA9IEFycmF5PHN0cmluZyB8IHN0cmluZ1tdIHwgbnVtYmVyIHwgbnVtYmVyW10gfCBEYXRlIHwgRGF0ZVtdIHwgYW55IHwgYW55W10+O1xuZXhwb3J0IHR5cGUgT3JpZW50YXRpb24gPSAnb2xkZXN0JyB8ICdsYXRlc3QnO1xuZXhwb3J0IGludGVyZmFjZSBOZ0NoYXJ0anNFdmVudCB7IGV2ZW50OiBNb3VzZUV2ZW50OyBhY3RpdmU6IEFycmF5PHt9PjsgfVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2NhbnZhc1tuZ0NoYXJ0anNdJywgZXhwb3J0QXM6ICduZ0NoYXJ0anMnIH0pXG5leHBvcnQgY2xhc3MgTmdDaGFydGpzRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIE9uSW5pdCB7XG5cbiAgLy8g5Zu+6KGo55qE54K56ZuG77yM5a6D5bqU6K+l5piv5pWw57uEPG51bWJlciBbXT7ku4XnlKjkuo7nur/vvIzmnaHlkozpm7fovr7vvIzlkKbliJnmlbDlrZdbXTtcbiAgQElucHV0KCkgZGF0YTogbnVtYmVyW10gfCBhbnlbXTtcbiAgLy8g55u45b2T5LqOY2hhcnQuanPlhoUgZGF0YToge2RhdGFzZXRzOiBbey4uLn1dfVxuICBASW5wdXQoKSBkYXRhc2V0czogQ2hhcnQuQ2hhcnREYXRhU2V0c1tdO1xuICAvLyB46L205qCH562+44CC6L+Z5a+55Zu+6KGo5p2l6K+05piv5b+F6KaB55qE77ya57q/77yM5p2h5ZKM6Zu36L6+44CC5bm25LiU5Y+q5piv5Zu+6KGo55qE5qCH562+77yI5oKs5YGc77yJ77yacG9sYXJBcmVh77yMcGll5ZKMZG91Z2hudXRcbiAgQElucHV0KCkgbGFiZWxzOiBMYWJlbHMgPSBbXTtcbiAgLy8g55u45b2T5LqOY2hhcnQuanPnmoRvcHRpb25cbiAgQElucHV0KCkgb3B0aW9uczogQ2hhcnQuQ2hhcnRPcHRpb25zID0ge307XG4gIC8vIOWGheiBlOaPkuS7tuWxnuaAp1xuICBASW5wdXQoKSBpbmxpbmVQbHVnaW5zOiBhbnlbXTtcbiAgLy8gY2hhcnRUeXBlIGxpbmUsIGJhciwgcmFkYXIsIHBpZSwgcG9sYXJBcmVhLCBkb3VnaG51dFxuICBASW5wdXQoKSBjaGFydFR5cGU6IENoYXJ0LkNoYXJ0VHlwZTtcbiAgLy8g5pWw5o2u6aKc6Imy77yM5aaC5p6c5rKh5pyJ5oyH5a6a77yM5bCG5L2/55So6buY6K6k5ZKMfOaIlumaj+acuuminOiJslxuICBASW5wdXQoKSBjb2xvcnM6IENvbG9yc1tdO1xuICAvLyDmmK/lkKbmmL7npLrlm77kvotcbiAgQElucHV0KCkgbGVnZW5kOiBib29sZWFuO1xuXG4gIEBJbnB1dCgpIGFkZGluZzogeyBsYWJlbHM6IExhYmVsc1tdLCBkYXRhOiBhbnlbXVtdIH07XG4gIEBJbnB1dCgpIHJlbW92aW5nOiB7IG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbiB9OyAgLy8gb3JpZW50YXRpb24gaXMgJ29sZGVzdCcgb3IgJ2xhdGVzdFxuICBASW5wdXQoKSByZXNldE9wdGlvbjogQ2hhcnQuQ2hhcnRUeXBlO1xuXG4gIC8vIOm8oOagh+eCueWHu+WbvuihqOaJgOacieeahOWMuuWfn1xuICBAT3V0cHV0KCkgY2hhcnRDbGljazogRXZlbnRFbWl0dGVyPE5nQ2hhcnRqc0V2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgLy8g6byg5qCH5oKs5rWu5Zyo5qCH562+5oiW6ICF5rS76LeD55qE54K55LiK6Z2i5pe2XG4gIEBPdXRwdXQoKSBjaGFydEhvdmVyOiBFdmVudEVtaXR0ZXI8TmdDaGFydGpzRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIHByaXZhdGUgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gIHByaXZhdGUgY2hhcnRfOiBDaGFydDtcbiAgcHJpdmF0ZSBpbml0RmxhZyA9IGZhbHNlO1xuICBwcml2YXRlIGhhc0NoYW5nZXMgPSBmYWxzZTtcblxuICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWY7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBuZ0NoYXJ0anNTZXJ2aWNlOiBOZ0NoYXJ0anNTZXJ2aWNlLFxuICAgIHByaXZhdGUgc3RvcmVTZXJ2aWNlOiBTdG9yZVNlcnZpY2UpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50OyAgIC8vIOiOt+WPluaMh+S7pOaJgOWcqGNhbnZhc+WFg+e0oFxuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5jdHggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpOyAvLyDojrflj5blhYPntKDnmoRjdHhcbiAgICB0aGlzLmluaXRGbGFnID0gdHJ1ZTsgLy8g5piv5ZCm5Yid5aeL5YyW5LqG55qE5qCH5b+XXG5cbiAgICBpZiAodGhpcy5kYXRhIHx8IHRoaXMuZGF0YXNldHMpIHsgLy8g5Yik5patZGF0YeWSjGRhdGFzZXRz5pyJ5LiA5Liq5pyJ5pWw5o2u5bCx5Yi35pawXG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgLy8gVE9ETzog5o+S5Lu25Y+Y5YyW5Yi35paw77yM5byA5pS+5Yi35paw5oyJ6ZKuXG4gICAgaWYgKHRoaXMuaW5pdEZsYWcpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGFuZ2VzIGFyZSBpbiB0aGUgZGF0YSBvciBkYXRhc2V0c1xuICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2RhdGEnKSB8fCBjaGFuZ2VzLmhhc093blByb3BlcnR5KCdkYXRhc2V0cycpKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmRhdGEpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNoYXJ0RGF0YShjaGFuZ2VzLmRhdGEuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNoYXJ0RGF0YShjaGFuZ2VzLmRhdGFzZXRzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2xhYmVscycpKSB7XG4gICAgICAgIHRoaXMuY2hhcnRfLmRhdGEubGFiZWxzID0gY2hhbmdlcy5sYWJlbHMuY3VycmVudFZhbHVlO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnbGVnZW5kJykpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMubGVnZW5kLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5sZWdlbmQucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhcnRfLm9wdGlvbnMubGVnZW5kLmRpc3BsYXkgPSBjaGFuZ2VzLmxlZ2VuZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnYWRkaW5nJykpIHtcbiAgICAgICAgdGhpcy5hZGREYXRhXyhjaGFuZ2VzLmFkZGluZy5jdXJyZW50VmFsdWUubGFiZWxzLCBjaGFuZ2VzLmFkZGluZy5jdXJyZW50VmFsdWUuZGF0YSk7XG4gICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdyZW1vdmluZycpKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnJlbW92aW5nLmN1cnJlbnRWYWx1ZS5vcmllbnRhdGlvbiA9PT0gJ29sZGVzdCcgfHwgY2hhbmdlcy5yZW1vdmluZy5jdXJyZW50VmFsdWUub3JpZW50YXRpb24gPT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVEYXRhXyhjaGFuZ2VzLnJlbW92aW5nLmN1cnJlbnRWYWx1ZS5vcmllbnRhdGlvbik7XG4gICAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnY2hhcnRUeXBlJykpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdyZXNldE9wdGlvbicpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jaGFydF8ub3B0aW9ucywgY2hhbmdlcy5yZXNldE9wdGlvbi5jdXJyZW50VmFsdWUpO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuY2hhcnRfLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jaGFydF8pIHtcbiAgICAgIHRoaXMuY2hhcnRfLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuY2hhcnRfID0gdm9pZCAwO1xuXG4gICAgICBpZiAodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdpZCcpKSB7XG4gICAgICAgIHRoaXMuc3RvcmVTZXJ2aWNlLnJlbW92ZUNoYXJ0KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmlkKTsgIC8vIGRlbGV0ZSBjaGFydCBpbnN0YW5jZS5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBnZXQgQ2hhcnRqcyBvYmplY3RcbiAgZ2V0IGNoYXJ0KCkgeyByZXR1cm4gdGhpcy5jaGFydF87IH1cblxuICAvLyB1cGRhdGUgY2hhcnRqc1xuICB1cGRhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5jaGFydF8udXBkYXRlKCk7XG4gIH1cblxuICAvLyBEeW5hbWljIGFkZCBkYXRhXG4gIGFkZERhdGEobGFiZWxzOiBMYWJlbHNbXSwgZGF0YTogYW55W11bXSk6IHZvaWQge1xuICAgIHRoaXMuYWRkRGF0YV8obGFiZWxzLCBkYXRhKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8vIER5bmFtaWMgcmVtb3ZlIGRhdGEsIG9yaWVudGF0aW9uIGlzICdpbGRlc3QnIG9yICdsYXRlc3QnXG4gIHJlbW92ZURhdGEob3JpZW50YXRpb246IE9yaWVudGF0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5yZW1vdmVEYXRhXyhvcmllbnRhdGlvbik7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVmcmVzaCgpOiB2b2lkIHtcbiAgICB0aGlzLm5nT25EZXN0cm95KCk7XG4gICAgdGhpcy5jaGFydF8gPSB0aGlzLmdldENoYXJ0QnVpbGRlcih0aGlzLmN0eC8qLCBkYXRhLCB0aGlzLm9wdGlvbnMqLyk7XG4gICAgaWYgKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgdGhpcy5zdG9yZVNlcnZpY2UuYWRkQ2hhcnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuaWQsIHRoaXMuY2hhcnRfKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUNoYXJ0RGF0YShuZXdEYXRhVmFsdWVzOiBudW1iZXJbXSB8IGFueVtdKTogdm9pZCB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV3RGF0YVZhbHVlc1swXS5kYXRhKSkge1xuICAgICAgdGhpcy5jaGFydF8uZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0OiBDaGFydC5DaGFydERhdGFTZXRzLCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgZGF0YXNldC5kYXRhID0gbmV3RGF0YVZhbHVlc1tpXS5kYXRhO1xuXG4gICAgICAgIGlmIChuZXdEYXRhVmFsdWVzW2ldLmxhYmVsKSB7XG4gICAgICAgICAgZGF0YXNldC5sYWJlbCA9IG5ld0RhdGFWYWx1ZXNbaV0ubGFiZWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYXJ0Xy5kYXRhLmRhdGFzZXRzWzBdLmRhdGEgPSBuZXdEYXRhVmFsdWVzO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q2hhcnRCdWlsZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELyosIGRhdGE6QXJyYXk8YW55Piwgb3B0aW9uczphbnkqLyk6IENoYXJ0IHtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZ2V0RGF0YXNldHMoKTtcblxuICAgIGNvbnN0IG9wdGlvbnM6IENoYXJ0LkNoYXJ0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7IC8vIOa3seWkjeWItm9wdGlvbnNcbiAgICBpZiAodGhpcy5sZWdlbmQgPT09IGZhbHNlKSB7ICAvLyDorr7nva5vcHRpb25z55qEbGVnZW5kIFRPRE86IOWQjue7rei/meS4quWxnuaAp+WOu+mZpO+8jOebtOaOpeWcqG9wdGlvbnPlhoXorr7nva5cbiAgICAgIG9wdGlvbnMubGVnZW5kID0geyBkaXNwbGF5OiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBob2NrIGZvciBvbkhvdmVyIGFuZCBvbkNsaWNrIGV2ZW50c1xuICAgIG9wdGlvbnMuaG92ZXIgPSBvcHRpb25zLmhvdmVyIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5ob3Zlci5vbkhvdmVyKSB7XG4gICAgICBvcHRpb25zLmhvdmVyLm9uSG92ZXIgPSAoZXZlbnQ6IE1vdXNlRXZlbnQsIGFjdGl2ZTogQXJyYXk8e30+KSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUgJiYgIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFydEhvdmVyLmVtaXQoeyBldmVudCwgYWN0aXZlIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMub25DbGljaykge1xuICAgICAgb3B0aW9ucy5vbkNsaWNrID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBhY3RpdmU6IEFycmF5PHt9PikgPT4ge1xuICAgICAgICB0aGlzLmNoYXJ0Q2xpY2suZW1pdCh7IGV2ZW50LCBhY3RpdmUgfSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICB0eXBlOiB0aGlzLmNoYXJ0VHlwZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWxzOiB0aGlzLmxhYmVscyxcbiAgICAgICAgZGF0YXNldHM6IGRhdGFzZXRzICAgLy8gVE9ETzog5ZCO57ut5pu05pS56L+Z5Liq5bGe5oCn5ZCN5a2X77yM5ZCm5YiZ6K2m5ZGKXG4gICAgICB9LFxuICAgICAgb3B0aW9uczogb3B0aW9ucywgICAvLyBUT0RPOiDlkI7nu63mm7TmlLnov5nkuKrlsZ7mgKflkI3lrZfvvIzlkKbliJnorablkYpcbiAgICAgIHBsdWdpbnM6IHRoaXMuaW5saW5lUGx1Z2luc1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IENoYXJ0KGN0eCwgb3B0cyk7XG4gIH1cblxuICAvLyDojrflj5YgY2hhcnQuanPnmoRkYXRhc2V0c+aVsOaNrlxuICBwcml2YXRlIGdldERhdGFzZXRzKCk6IENoYXJ0LkNoYXJ0RGF0YVNldHNbXSB7XG4gICAgbGV0IGRhdGFzZXRzOiBDaGFydC5DaGFydERhdGFTZXRzW10gPSB2b2lkIDA7XG4gICAgLy8gaW4gY2FzZSBpZiBkYXRhc2V0cyBpcyBub3QgcHJvdmlkZWQsIGJ1dCBkYXRhIGlzIHByZXNlbnRcbiAgICBpZiAoIXRoaXMuZGF0YXNldHMgfHwgIXRoaXMuZGF0YXNldHMubGVuZ3RoICYmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YVswXSkpIHtcbiAgICAgICAgZGF0YXNldHMgPSAodGhpcy5kYXRhIGFzIG51bWJlcltdW10pLm1hcCgoZGF0YTogbnVtYmVyW10sIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICByZXR1cm4geyBkYXRhLCBsYWJlbDogdGhpcy5sYWJlbHNbaW5kZXhdIHx8IGBMYWJlbCAke2luZGV4fWAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhc2V0cyA9IFt7IGRhdGE6IHRoaXMuZGF0YSwgbGFiZWw6IGBMYWJlbCAwYCB9XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhc2V0cyAmJiB0aGlzLmRhdGFzZXRzLmxlbmd0aCB8fCAoZGF0YXNldHMgJiYgZGF0YXNldHMubGVuZ3RoKSkge1xuICAgICAgLy8gZml4IGVsbSB0eXBlLCBwcmUgdHlwZSBpcyBudW1iZXJcbiAgICAgIGRhdGFzZXRzID0gKHRoaXMuZGF0YXNldHMgfHwgZGF0YXNldHMpLm1hcCgoZWxtOiBDaGFydC5DaGFydERhdGFTZXRzLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0VsbTogQ2hhcnQuQ2hhcnREYXRhU2V0cyA9IE9iamVjdC5hc3NpZ24oe30sIGVsbSk7XG4gICAgICAgIGlmICh0aGlzLmNvbG9ycyAmJiB0aGlzLmNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0VsbSwgdGhpcy5jb2xvcnNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0VsbSwgZ2V0Q29sb3JzKHRoaXMuY2hhcnRUeXBlLCBpbmRleCwgbmV3RWxtLmRhdGEubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0VsbTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghZGF0YXNldHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbmctY2hhcnRqcyBjb25maWd1cmF0aW9uIGVycm9yLFxuICAgICAgZGF0YSBvciBkYXRhc2V0cyBmaWVsZCBhcmUgcmVxdWlyZWQgdG8gcmVuZGVyIGNoYXIgJHt0aGlzLmNoYXJ0VHlwZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YXNldHM7XG4gIH1cblxuICBwcml2YXRlIGFkZERhdGFfKGxhYmVsczogTGFiZWxzW10sIGRhdGE6IGFueVtdW10pOiB2b2lkIHtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgbGFiZWxzXG4gICAgbGFiZWxzLmZvckVhY2goKGxhYmVsKSA9PiB7IHRoaXMuY2hhcnRfLmRhdGEubGFiZWxzLnB1c2gobGFiZWwpOyB9KTtcblxuICAgIHRoaXMuY2hhcnRfLmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhW2luZGV4XSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFbaW5kZXhdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGF0YXNldC5kYXRhLnB1c2goZGF0YVtpbmRleF1baV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnVGhlIGFkZGVkIGRhdGEgZG9lcyBub3QgbWF0Y2ggdGhlIG9yaWdpbmFsIGRhdGEnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVEYXRhXyhvcmllbnRhdGlvbjogT3JpZW50YXRpb24pOiB2b2lkIHtcbiAgICAvLyBmaXg6IHN1cHBvcnQgdG8gb2xkZXN0IGZlYXR1cmVcbiAgICBpZiAob3JpZW50YXRpb24gPT09ICdsYXRlc3QnKSB7XG4gICAgICB0aGlzLmNoYXJ0Xy5kYXRhLmxhYmVscy5wb3AoKTtcbiAgICAgIHRoaXMuY2hhcnRfLmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldDogQ2hhcnQuQ2hhcnREYXRhU2V0cykgPT4ge1xuICAgICAgICBkYXRhc2V0LmRhdGEucG9wKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSAnb2xkZXN0Jykge1xuICAgICAgdGhpcy5jaGFydF8uZGF0YS5sYWJlbHMuc2hpZnQoKTtcbiAgICAgIHRoaXMuY2hhcnRfLmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldDogQ2hhcnQuQ2hhcnREYXRhU2V0cykgPT4ge1xuICAgICAgICBkYXRhc2V0LmRhdGEuc2hpZnQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIl19