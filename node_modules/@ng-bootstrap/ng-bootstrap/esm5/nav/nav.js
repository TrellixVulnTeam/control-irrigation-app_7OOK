/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Attribute, ChangeDetectorRef, ContentChildren, Directive, ElementRef, EventEmitter, forwardRef, Inject, Input, Output, QueryList, TemplateRef } from '@angular/core';
import { isDefined } from '../util/util';
import { NgbNavConfig } from './nav-config';
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
var isValidNavId = (/**
 * @param {?} id
 * @return {?}
 */
function (id) { return isDefined(id) && id !== ''; });
var ɵ0 = isValidNavId;
/** @type {?} */
var navCounter = 0;
/**
 * Context passed to the nav content template.
 *
 * See [this demo](#/components/nav/examples#keep-content) as the example.
 *
 * \@since 5.2.0
 * @record
 */
export function NgbNavContentContext() { }
if (false) {
    /**
     * If `true`, current nav content is visible and active
     * @type {?}
     */
    NgbNavContentContext.prototype.$implicit;
}
/**
 * This directive must be used to wrap content to be displayed in the nav.
 *
 * \@since 5.2.0
 */
var NgbNavContent = /** @class */ (function () {
    function NgbNavContent(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    NgbNavContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbNavContent.ɵfac = function NgbNavContent_Factory(t) { return new (t || NgbNavContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NgbNavContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbNavContent, selectors: [["ng-template", "ngbNavContent", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbNavContent, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbNavContent]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return NgbNavContent;
}());
export { NgbNavContent };
if (false) {
    /** @type {?} */
    NgbNavContent.prototype.templateRef;
}
/**
 * The directive used to group nav link and related nav content. As well as set nav identifier and some options.
 *
 * \@since 5.2.0
 */
var NgbNavItem = /** @class */ (function () {
    function NgbNavItem(nav, elementRef) {
        this.elementRef = elementRef;
        /**
         * If `true`, the current nav item is disabled and can't be toggled by user.
         *
         * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.
         */
        this.disabled = false;
        // TODO: cf https://github.com/angular/angular/issues/30106
        this._nav = nav;
    }
    /**
     * @return {?}
     */
    NgbNavItem.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        // We are using @ContentChildren instead of @ContentChild as in the Angular version being used
        // only @ContentChildren allows us to specify the {descendants: false} option.
        // Without {descendants: false} we are hitting bugs described in:
        // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240
        this.contentTpl = this.contentTpls.first;
    };
    /**
     * @return {?}
     */
    NgbNavItem.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!isDefined(this.domId)) {
            this.domId = "ngb-nav-" + navCounter++;
        }
    };
    Object.defineProperty(NgbNavItem.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () { return this._nav.activeId === this.id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgbNavItem.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () { return isValidNavId(this._id) ? this._id : this.domId; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgbNavItem.prototype, "panelDomId", {
        get: /**
         * @return {?}
         */
        function () { return this.domId + "-panel"; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgbNavItem.prototype.isPanelInDom = /**
     * @return {?}
     */
    function () {
        return (isDefined(this.destroyOnHide) ? !this.destroyOnHide : !this._nav.destroyOnHide) || this.active;
    };
    /** @nocollapse */
    NgbNavItem.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                         * @return {?}
                         */
                        function () { return NgbNav; })),] }] },
        { type: ElementRef }
    ]; };
    NgbNavItem.propDecorators = {
        destroyOnHide: [{ type: Input }],
        disabled: [{ type: Input }],
        domId: [{ type: Input }],
        _id: [{ type: Input, args: ['ngbNavItem',] }],
        contentTpls: [{ type: ContentChildren, args: [NgbNavContent, { descendants: false },] }]
    };
NgbNavItem.ɵfac = function NgbNavItem_Factory(t) { return new (t || NgbNavItem)(ɵngcc0.ɵɵdirectiveInject(forwardRef(( /**
                 * @return {?}
                 */function () { return NgbNav; }))), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgbNavItem.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbNavItem, selectors: [["", "ngbNavItem", ""]], contentQueries: function NgbNavItem_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbNavContent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTpls = _t);
    } }, hostVars: 2, hostBindings: function NgbNavItem_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nav-item", true);
    } }, inputs: { disabled: "disabled", domId: "domId", destroyOnHide: "destroyOnHide", _id: ["ngbNavItem", "_id"] }, exportAs: ["ngbNavItem"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbNavItem, [{
        type: Directive,
        args: [{ selector: '[ngbNavItem]', exportAs: 'ngbNavItem', host: { '[class.nav-item]': 'true' } }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [forwardRef(( /**
                                     * @return {?}
                                     */function () { return NgbNav; }))]
            }] }, { type: ɵngcc0.ElementRef }]; }, { disabled: [{
            type: Input
        }], domId: [{
            type: Input
        }], destroyOnHide: [{
            type: Input
        }], _id: [{
            type: Input,
            args: ['ngbNavItem']
        }], contentTpls: [{
            type: ContentChildren,
            args: [NgbNavContent, { descendants: false }]
        }] }); })();
    return NgbNavItem;
}());
export { NgbNavItem };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgbNavItem.prototype._nav;
    /**
     * If `true`, non-active current nav item content will be removed from DOM
     * Otherwise it will just be hidden
     * @type {?}
     */
    NgbNavItem.prototype.destroyOnHide;
    /**
     * If `true`, the current nav item is disabled and can't be toggled by user.
     *
     * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.
     * @type {?}
     */
    NgbNavItem.prototype.disabled;
    /**
     * The id used for the DOM elements.
     * Must be unique inside the document in case you have multiple `ngbNav`s on the page.
     *
     * Autogenerated as `ngb-nav-XXX` if not provided.
     * @type {?}
     */
    NgbNavItem.prototype.domId;
    /**
     * The id used as a model for active nav.
     * It can be anything, but must be unique inside one `ngbNav`.
     *
     * The only limitation is that it is not possible to have the `''` (empty string) as id,
     * because ` ngbNavItem `, `ngbNavItem=''` and `[ngbNavItem]="''"` are indistinguishable
     * @type {?}
     */
    NgbNavItem.prototype._id;
    /** @type {?} */
    NgbNavItem.prototype.contentTpl;
    /** @type {?} */
    NgbNavItem.prototype.contentTpls;
    /** @type {?} */
    NgbNavItem.prototype.elementRef;
}
/**
 * A nav directive that helps with implementing tabbed navigation components.
 *
 * \@since 5.2.0
 */
var NgbNav = /** @class */ (function () {
    function NgbNav(role, config, _cd) {
        this.role = role;
        this._cd = _cd;
        /**
         * The event emitted after the active nav changes
         * The payload of the event is the newly active nav id
         *
         * If you want to prevent nav change, you should use `(navChange)` event
         */
        this.activeIdChange = new EventEmitter();
        /**
         * The nav change event emitted right before the nav change happens on user click.
         *
         * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
         *
         * See [`NgbNavChangeEvent`](#/components/nav/api#NgbNavChangeEvent) for payload details.
         */
        this.navChange = new EventEmitter();
        this.destroyOnHide = config.destroyOnHide;
        this.orientation = config.orientation;
        this.roles = config.roles;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    NgbNav.prototype.click = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (!item.disabled) {
            this._updateActiveId(item.id);
        }
    };
    /**
     * Selects the nav with the given id and shows its associated pane.
     * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
     */
    /**
     * Selects the nav with the given id and shows its associated pane.
     * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} id
     * @return {?}
     */
    NgbNav.prototype.select = /**
     * Selects the nav with the given id and shows its associated pane.
     * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} id
     * @return {?}
     */
    function (id) { this._updateActiveId(id, false); };
    /**
     * @return {?}
     */
    NgbNav.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (!isDefined(this.activeId)) {
            /** @type {?} */
            var nextId = this.items.first ? this.items.first.id : null;
            if (isValidNavId(nextId)) {
                this._updateActiveId(nextId, false);
                this._cd.detectChanges();
            }
        }
    };
    /**
     * @private
     * @param {?} nextId
     * @param {?=} emitNavChange
     * @return {?}
     */
    NgbNav.prototype._updateActiveId = /**
     * @private
     * @param {?} nextId
     * @param {?=} emitNavChange
     * @return {?}
     */
    function (nextId, emitNavChange) {
        if (emitNavChange === void 0) { emitNavChange = true; }
        if (this.activeId !== nextId) {
            /** @type {?} */
            var defaultPrevented_1 = false;
            if (emitNavChange) {
                this.navChange.emit({ activeId: this.activeId, nextId: nextId, preventDefault: (/**
                     * @return {?}
                     */
                    function () { defaultPrevented_1 = true; }) });
            }
            if (!defaultPrevented_1) {
                this.activeId = nextId;
                this.activeIdChange.emit(nextId);
            }
        }
    };
    /** @nocollapse */
    NgbNav.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Attribute, args: ['role',] }] },
        { type: NgbNavConfig },
        { type: ChangeDetectorRef }
    ]; };
    NgbNav.propDecorators = {
        activeId: [{ type: Input }],
        activeIdChange: [{ type: Output }],
        destroyOnHide: [{ type: Input }],
        orientation: [{ type: Input }],
        roles: [{ type: Input }],
        items: [{ type: ContentChildren, args: [NgbNavItem,] }],
        navChange: [{ type: Output }]
    };
NgbNav.ɵfac = function NgbNav_Factory(t) { return new (t || NgbNav)(ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NgbNavConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NgbNav.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbNav, selectors: [["", "ngbNav", ""]], contentQueries: function NgbNav_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbNavItem, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, hostVars: 6, hostBindings: function NgbNav_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-orientation", ctx.orientation === "vertical" && ctx.roles === "tablist" ? "vertical" : undefined)("role", ctx.role ? ctx.role : ctx.roles ? "tablist" : undefined);
        ɵngcc0.ɵɵclassProp("nav", true)("flex-column", ctx.orientation === "vertical");
    } }, inputs: { destroyOnHide: "destroyOnHide", orientation: "orientation", roles: "roles", activeId: "activeId" }, outputs: { activeIdChange: "activeIdChange", navChange: "navChange" }, exportAs: ["ngbNav"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbNav, [{
        type: Directive,
        args: [{
                selector: '[ngbNav]',
                exportAs: 'ngbNav',
                host: {
                    '[class.nav]': 'true',
                    '[class.flex-column]': "orientation === 'vertical'",
                    '[attr.aria-orientation]': "orientation === 'vertical' && roles === 'tablist' ? 'vertical' : undefined",
                    '[attr.role]': "role ? role : roles ? 'tablist' : undefined"
                }
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Attribute,
                args: ['role']
            }] }, { type: NgbNavConfig }, { type: ɵngcc0.ChangeDetectorRef }]; }, { activeIdChange: [{
            type: Output
        }], navChange: [{
            type: Output
        }], destroyOnHide: [{
            type: Input
        }], orientation: [{
            type: Input
        }], roles: [{
            type: Input
        }], activeId: [{
            type: Input
        }], items: [{
            type: ContentChildren,
            args: [NgbNavItem]
        }] }); })();
    return NgbNav;
}());
export { NgbNav };
if (false) {
    /**
     * The id of the nav that should be active
     *
     * You could also use the `.select()` method and the `(navChange)` event
     * @type {?}
     */
    NgbNav.prototype.activeId;
    /**
     * The event emitted after the active nav changes
     * The payload of the event is the newly active nav id
     *
     * If you want to prevent nav change, you should use `(navChange)` event
     * @type {?}
     */
    NgbNav.prototype.activeIdChange;
    /**
     * If `true`, non-active nav content will be removed from DOM
     * Otherwise it will just be hidden
     * @type {?}
     */
    NgbNav.prototype.destroyOnHide;
    /**
     * The orientation of navs.
     *
     * Using `vertical` will also add the `aria-orientation` attribute
     * @type {?}
     */
    NgbNav.prototype.orientation;
    /**
     * Role attribute generating strategy:
     * - `false` - no role attributes will be generated
     * - `'tablist'` - 'tablist', 'tab' and 'tabpanel' will be generated (default)
     * @type {?}
     */
    NgbNav.prototype.roles;
    /** @type {?} */
    NgbNav.prototype.items;
    /**
     * The nav change event emitted right before the nav change happens on user click.
     *
     * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
     *
     * See [`NgbNavChangeEvent`](#/components/nav/api#NgbNavChangeEvent) for payload details.
     * @type {?}
     */
    NgbNav.prototype.navChange;
    /** @type {?} */
    NgbNav.prototype.role;
    /**
     * @type {?}
     * @private
     */
    NgbNav.prototype._cd;
}
/**
 * A directive to put on the nav link.
 *
 * \@since 5.2.0
 */
var NgbNavLink = /** @class */ (function () {
    function NgbNavLink(role, navItem, nav) {
        this.role = role;
        this.navItem = navItem;
        this.nav = nav;
    }
    /**
     * @return {?}
     */
    NgbNavLink.prototype.hasNavItemClass = /**
     * @return {?}
     */
    function () {
        // with alternative markup we have to add `.nav-item` class, because `ngbNavItem` is on the ng-container
        return this.navItem.elementRef.nativeElement.nodeType === Node.COMMENT_NODE;
    };
    /** @nocollapse */
    NgbNavLink.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Attribute, args: ['role',] }] },
        { type: NgbNavItem },
        { type: NgbNav }
    ]; };
NgbNavLink.ɵfac = function NgbNavLink_Factory(t) { return new (t || NgbNavLink)(ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NgbNavItem), ɵngcc0.ɵɵdirectiveInject(NgbNav)); };
NgbNavLink.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbNavLink, selectors: [["a", "ngbNavLink", ""]], hostAttrs: ["href", ""], hostVars: 14, hostBindings: function NgbNavLink_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NgbNavLink_click_HostBindingHandler($event) { ctx.nav.click(ctx.navItem); return $event.preventDefault(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.navItem.domId);
        ɵngcc0.ɵɵattribute("role", ctx.role ? ctx.role : ctx.nav.roles ? "tab" : undefined)("tabindex", ctx.navItem.disabled ? 0 - 1 : undefined)("aria-controls", ctx.navItem.isPanelInDom() ? ctx.navItem.panelDomId : null)("aria-selected", ctx.navItem.active)("aria-disabled", ctx.navItem.disabled);
        ɵngcc0.ɵɵclassProp("nav-link", true)("nav-item", ctx.hasNavItemClass())("active", ctx.navItem.active)("disabled", ctx.navItem.disabled);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbNavLink, [{
        type: Directive,
        args: [{
                selector: 'a[ngbNavLink]',
                host: {
                    '[id]': 'navItem.domId',
                    '[class.nav-link]': 'true',
                    '[class.nav-item]': 'hasNavItemClass()',
                    '[attr.role]': "role ? role : nav.roles ? 'tab' : undefined",
                    'href': '',
                    '[class.active]': 'navItem.active',
                    '[class.disabled]': 'navItem.disabled',
                    '[attr.tabindex]': 'navItem.disabled ? -1 : undefined',
                    '[attr.aria-controls]': 'navItem.isPanelInDom() ? navItem.panelDomId : null',
                    '[attr.aria-selected]': 'navItem.active',
                    '[attr.aria-disabled]': 'navItem.disabled',
                    '(click)': 'nav.click(navItem); $event.preventDefault()'
                }
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Attribute,
                args: ['role']
            }] }, { type: NgbNavItem }, { type: NgbNav }]; }, null); })();
    return NgbNavLink;
}());
export { NgbNavLink };
if (false) {
    /** @type {?} */
    NgbNavLink.prototype.role;
    /** @type {?} */
    NgbNavLink.prototype.navItem;
    /** @type {?} */
    NgbNavLink.prototype.nav;
}
/**
 * The payload of the change event emitted right before the nav change happens on user click.
 *
 * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
 *
 * \@since 5.2.0
 * @record
 */
export function NgbNavChangeEvent() { }
if (false) {
    /**
     * Id of the currently active nav.
     * @type {?}
     */
    NgbNavChangeEvent.prototype.activeId;
    /**
     * Id of the newly selected nav.
     * @type {?}
     */
    NgbNavChangeEvent.prototype.nextId;
    /**
     * Function that will prevent nav change if called.
     * @type {?}
     */
    NgbNavChangeEvent.prototype.preventDefault;
}
export { ɵ0 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2LmpzIiwic291cmNlcyI6WyJuZzovQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvbmF2L25hdi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUdMLFNBQVMsRUFDVCxpQkFBaUIsRUFDakIsZUFBZSxFQUNmLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUVMLE1BQU0sRUFDTixTQUFTLEVBQ1QsV0FBVyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLGNBQWMsQ0FBQzs7O0FBRTFCLElBQVYsWUFBWTs7OztBQUFHLFVBQUMsRUFBTyxJQUFLLE9BQUEsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQTFCLENBQTBCLENBQUE7OztJQUV4RCxVQUFVLEdBQUcsQ0FBQzs7Ozs7Ozs7O0FBU2xCLDBDQUtDOzs7Ozs7SUFEQyx5Q0FBbUI7Ozs7Ozs7QUFTckI7SUFFRSx1QkFBbUIsV0FBNkI7UUFBN0IsZ0JBQVcsR0FBWCxXQUFXLENBQWtCO0lBQUcsQ0FBQyxBQUQ3Qzs7MEJBRFIsU0FBUyxTQUFDLEVBQUMsUUFBUSxFQUFFOzBCQUE0QixFQUFDLFpBN0JqRCxXQUFXOzs7Ozs7OzRFQUNGO0lBK0JYLG9CQUFDO0NBQUEsQUFIRCxJQUdDO1NBRlksYUFBYTs7O0lBQ1osb0NBQW9DOzs7Ozs7O0FBU2xEO0lBc0NFLG9CQUE4QyxHQUFHLEVBQVMsVUFBMkI7UUFBM0IsZUFBVSxHQUFWLFVBQVUsQ0FBaUI7Ozs7OztRQXZCNUUsYUFBUSxHQUFHLEtBQUssQ0FBQztRQXdCeEIsMkRBQTJEO1FBQzNELElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0lBQ2xCLENBQUM7Ozs7SUFFRCwwQ0FBcUI7OztJQUFyQjtRQUNFLDhGQUE4RjtR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LE1BQU0sRUFBRSxEQWUwRCxVQUFVO0VBZnJELGNBZW1FLE1BQU07R0FkaEc7V0FBa0IsRUFBRSxNQUFNLDBCQUMxQixrQkFBa0IsRUFBRSxtQkFBbUIsMEJBQ3ZDLGFBQWEsRUFBRSw2Q0FBNkM7TUFDNUQsTUFBTSxFQUFFLEVBQUUsMEJBQ1YsZ0JBQWdCLEVBQUUsZ0JBQWdCLDBCQUNsQyxrQkFBa0IsRUFBRSxrQkFBa0IsMEJBQ3RDLGlCQUFpQixFQUFFO1FBQW1DLDBCQUN0RCxzQkFBc0IsRUFBRSxvREFBb0QsMEJBQzVFO0lBQXNCLEVBQUU7RUFBZ0IsMEJBQ3hDLHNCQUFzQixFQUFFO2NBQWtCLDBCQUMxQyxTQUFTLEVBQUUsNkNBQTZDLHNCQUN6RCxrQkFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswRUFJSztJQUlOLGlCQUFDO0NBQUEsQUF4QkQsSUF3QkM7U0FQWSxVQUFVOzs7SUFDVCwwQkFBc0M7O0lBQUUsNkJBQTBCOztJQUFFLHlCQUFrQjs7Ozs7Ozs7OztBQWdCcEcsdUNBZUM7Ozs7OztJQVhDLHFDQUFjOzs7OztJQUtkLG1DQUFZOzs7OztJQUtaLDJDQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyQ29udGVudENoZWNrZWQsXG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEF0dHJpYnV0ZSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIGZvcndhcmRSZWYsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQge05nYk5hdkNvbmZpZ30gZnJvbSAnLi9uYXYtY29uZmlnJztcblxuY29uc3QgaXNWYWxpZE5hdklkID0gKGlkOiBhbnkpID0+IGlzRGVmaW5lZChpZCkgJiYgaWQgIT09ICcnO1xuXG5sZXQgbmF2Q291bnRlciA9IDA7XG5cbi8qKlxuICogQ29udGV4dCBwYXNzZWQgdG8gdGhlIG5hdiBjb250ZW50IHRlbXBsYXRlLlxuICpcbiAqIFNlZSBbdGhpcyBkZW1vXSgjL2NvbXBvbmVudHMvbmF2L2V4YW1wbGVzI2tlZXAtY29udGVudCkgYXMgdGhlIGV4YW1wbGUuXG4gKlxuICogQHNpbmNlIDUuMi4wXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmdiTmF2Q29udGVudENvbnRleHQge1xuICAvKipcbiAgICogSWYgYHRydWVgLCBjdXJyZW50IG5hdiBjb250ZW50IGlzIHZpc2libGUgYW5kIGFjdGl2ZVxuICAgKi9cbiAgJGltcGxpY2l0OiBib29sZWFuO1xufVxuXG5cbi8qKlxuICogVGhpcyBkaXJlY3RpdmUgbXVzdCBiZSB1c2VkIHRvIHdyYXAgY29udGVudCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIG5hdi5cbiAqXG4gKiBAc2luY2UgNS4yLjBcbiAqL1xuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICduZy10ZW1wbGF0ZVtuZ2JOYXZDb250ZW50XSd9KVxuZXhwb3J0IGNsYXNzIE5nYk5hdkNvbnRlbnQge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4pIHt9XG59XG5cblxuLyoqXG4gKiBUaGUgZGlyZWN0aXZlIHVzZWQgdG8gZ3JvdXAgbmF2IGxpbmsgYW5kIHJlbGF0ZWQgbmF2IGNvbnRlbnQuIEFzIHdlbGwgYXMgc2V0IG5hdiBpZGVudGlmaWVyIGFuZCBzb21lIG9wdGlvbnMuXG4gKlxuICogQHNpbmNlIDUuMi4wXG4gKi9cbkBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnW25nYk5hdkl0ZW1dJywgZXhwb3J0QXM6ICduZ2JOYXZJdGVtJywgaG9zdDogeydbY2xhc3MubmF2LWl0ZW1dJzogJ3RydWUnfX0pXG5leHBvcnQgY2xhc3MgTmdiTmF2SXRlbSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudENoZWNrZWQsIE9uSW5pdCB7XG4gIHByaXZhdGUgX25hdjogTmdiTmF2O1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIG5vbi1hY3RpdmUgY3VycmVudCBuYXYgaXRlbSBjb250ZW50IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIERPTVxuICAgKiBPdGhlcndpc2UgaXQgd2lsbCBqdXN0IGJlIGhpZGRlblxuICAgKi9cbiAgQElucHV0KCkgZGVzdHJveU9uSGlkZTtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY3VycmVudCBuYXYgaXRlbSBpcyBkaXNhYmxlZCBhbmQgY2FuJ3QgYmUgdG9nZ2xlZCBieSB1c2VyLlxuICAgKlxuICAgKiBOZXZlcnRoZWxlc3MgZGlzYWJsZWQgbmF2IGNhbiBiZSBzZWxlY3RlZCBwcm9ncmFtbWF0aWNhbGx5IHZpYSB0aGUgYC5zZWxlY3QoKWAgbWV0aG9kIGFuZCB0aGUgYFthY3RpdmVJZF1gIGJpbmRpbmcuXG4gICAqL1xuICBASW5wdXQoKSBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgaWQgdXNlZCBmb3IgdGhlIERPTSBlbGVtZW50cy5cbiAgICogTXVzdCBiZSB1bmlxdWUgaW5zaWRlIHRoZSBkb2N1bWVudCBpbiBjYXNlIHlvdSBoYXZlIG11bHRpcGxlIGBuZ2JOYXZgcyBvbiB0aGUgcGFnZS5cbiAgICpcbiAgICogQXV0b2dlbmVyYXRlZCBhcyBgbmdiLW5hdi1YWFhgIGlmIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIEBJbnB1dCgpIGRvbUlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBpZCB1c2VkIGFzIGEgbW9kZWwgZm9yIGFjdGl2ZSBuYXYuXG4gICAqIEl0IGNhbiBiZSBhbnl0aGluZywgYnV0IG11c3QgYmUgdW5pcXVlIGluc2lkZSBvbmUgYG5nYk5hdmAuXG4gICAqXG4gICAqIFRoZSBvbmx5IGxpbWl0YXRpb24gaXMgdGhhdCBpdCBpcyBub3QgcG9zc2libGUgdG8gaGF2ZSB0aGUgYCcnYCAoZW1wdHkgc3RyaW5nKSBhcyBpZCxcbiAgICogYmVjYXVzZSBgIG5nYk5hdkl0ZW0gYCwgYG5nYk5hdkl0ZW09JydgIGFuZCBgW25nYk5hdkl0ZW1dPVwiJydcImAgYXJlIGluZGlzdGluZ3Vpc2hhYmxlXG4gICAqL1xuICBASW5wdXQoJ25nYk5hdkl0ZW0nKSBfaWQ6IGFueTtcblxuICBjb250ZW50VHBsOiBOZ2JOYXZDb250ZW50IHwgbnVsbDtcblxuICBAQ29udGVudENoaWxkcmVuKE5nYk5hdkNvbnRlbnQsIHtkZXNjZW5kYW50czogZmFsc2V9KSBjb250ZW50VHBsczogUXVlcnlMaXN0PE5nYk5hdkNvbnRlbnQ+O1xuXG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBOZ2JOYXYpKSBuYXYsIHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmPGFueT4pIHtcbiAgICAvLyBUT0RPOiBjZiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMDEwNlxuICAgIHRoaXMuX25hdiA9IG5hdjtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICAvLyBXZSBhcmUgdXNpbmcgQENvbnRlbnRDaGlsZHJlbiBpbnN0ZWFkIG9mIEBDb250ZW50Q2hpbGQgYXMgaW4gdGhlIEFuZ3VsYXIgdmVyc2lvbiBiZWluZyB1c2VkXG4gICAgLy8gb25seSBAQ29udGVudENoaWxkcmVuIGFsbG93cyB1cyB0byBzcGVjaWZ5IHRoZSB7ZGVzY2VuZGFudHM6IGZhbHNlfSBvcHRpb24uXG4gICAgLy8gV2l0aG91dCB7ZGVzY2VuZGFudHM6IGZhbHNlfSB3ZSBhcmUgaGl0dGluZyBidWdzIGRlc2NyaWJlZCBpbjpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbmctYm9vdHN0cmFwL25nLWJvb3RzdHJhcC9pc3N1ZXMvMjI0MFxuICAgIHRoaXMuY29udGVudFRwbCA9IHRoaXMuY29udGVudFRwbHMuZmlyc3Q7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLmRvbUlkKSkge1xuICAgICAgdGhpcy5kb21JZCA9IGBuZ2ItbmF2LSR7bmF2Q291bnRlcisrfWA7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHsgcmV0dXJuIHRoaXMuX25hdi5hY3RpdmVJZCA9PT0gdGhpcy5pZDsgfVxuXG4gIGdldCBpZCgpIHsgcmV0dXJuIGlzVmFsaWROYXZJZCh0aGlzLl9pZCkgPyB0aGlzLl9pZCA6IHRoaXMuZG9tSWQ7IH1cblxuICBnZXQgcGFuZWxEb21JZCgpIHsgcmV0dXJuIGAke3RoaXMuZG9tSWR9LXBhbmVsYDsgfVxuXG4gIGlzUGFuZWxJbkRvbSgpIHtcbiAgICByZXR1cm4gKGlzRGVmaW5lZCh0aGlzLmRlc3Ryb3lPbkhpZGUpID8gIXRoaXMuZGVzdHJveU9uSGlkZSA6ICF0aGlzLl9uYXYuZGVzdHJveU9uSGlkZSkgfHwgdGhpcy5hY3RpdmU7XG4gIH1cbn1cblxuXG4vKipcbiAqIEEgbmF2IGRpcmVjdGl2ZSB0aGF0IGhlbHBzIHdpdGggaW1wbGVtZW50aW5nIHRhYmJlZCBuYXZpZ2F0aW9uIGNvbXBvbmVudHMuXG4gKlxuICogQHNpbmNlIDUuMi4wXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuZ2JOYXZdJyxcbiAgZXhwb3J0QXM6ICduZ2JOYXYnLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5uYXZdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuZmxleC1jb2x1bW5dJzogYG9yaWVudGF0aW9uID09PSAndmVydGljYWwnYCxcbiAgICAnW2F0dHIuYXJpYS1vcmllbnRhdGlvbl0nOiBgb3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgcm9sZXMgPT09ICd0YWJsaXN0JyA/ICd2ZXJ0aWNhbCcgOiB1bmRlZmluZWRgLFxuICAgICdbYXR0ci5yb2xlXSc6IGByb2xlID8gcm9sZSA6IHJvbGVzID8gJ3RhYmxpc3QnIDogdW5kZWZpbmVkYCxcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBOZ2JOYXYgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGUgbmF2IHRoYXQgc2hvdWxkIGJlIGFjdGl2ZVxuICAgKlxuICAgKiBZb3UgY291bGQgYWxzbyB1c2UgdGhlIGAuc2VsZWN0KClgIG1ldGhvZCBhbmQgdGhlIGAobmF2Q2hhbmdlKWAgZXZlbnRcbiAgICovXG4gIEBJbnB1dCgpIGFjdGl2ZUlkOiBhbnk7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCBlbWl0dGVkIGFmdGVyIHRoZSBhY3RpdmUgbmF2IGNoYW5nZXNcbiAgICogVGhlIHBheWxvYWQgb2YgdGhlIGV2ZW50IGlzIHRoZSBuZXdseSBhY3RpdmUgbmF2IGlkXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHByZXZlbnQgbmF2IGNoYW5nZSwgeW91IHNob3VsZCB1c2UgYChuYXZDaGFuZ2UpYCBldmVudFxuICAgKi9cbiAgQE91dHB1dCgpIGFjdGl2ZUlkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgbm9uLWFjdGl2ZSBuYXYgY29udGVudCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBET01cbiAgICogT3RoZXJ3aXNlIGl0IHdpbGwganVzdCBiZSBoaWRkZW5cbiAgICovXG4gIEBJbnB1dCgpIGRlc3Ryb3lPbkhpZGU7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmllbnRhdGlvbiBvZiBuYXZzLlxuICAgKlxuICAgKiBVc2luZyBgdmVydGljYWxgIHdpbGwgYWxzbyBhZGQgdGhlIGBhcmlhLW9yaWVudGF0aW9uYCBhdHRyaWJ1dGVcbiAgICovXG4gIEBJbnB1dCgpIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnO1xuXG4gIC8qKlxuICAgKiBSb2xlIGF0dHJpYnV0ZSBnZW5lcmF0aW5nIHN0cmF0ZWd5OlxuICAgKiAtIGBmYWxzZWAgLSBubyByb2xlIGF0dHJpYnV0ZXMgd2lsbCBiZSBnZW5lcmF0ZWRcbiAgICogLSBgJ3RhYmxpc3QnYCAtICd0YWJsaXN0JywgJ3RhYicgYW5kICd0YWJwYW5lbCcgd2lsbCBiZSBnZW5lcmF0ZWQgKGRlZmF1bHQpXG4gICAqL1xuICBASW5wdXQoKSByb2xlczogJ3RhYmxpc3QnIHwgZmFsc2U7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihOZ2JOYXZJdGVtKSBpdGVtczogUXVlcnlMaXN0PE5nYk5hdkl0ZW0+O1xuXG4gIGNvbnN0cnVjdG9yKEBBdHRyaWJ1dGUoJ3JvbGUnKSBwdWJsaWMgcm9sZTogc3RyaW5nLCBjb25maWc6IE5nYk5hdkNvbmZpZywgcHJpdmF0ZSBfY2Q6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy5kZXN0cm95T25IaWRlID0gY29uZmlnLmRlc3Ryb3lPbkhpZGU7XG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IGNvbmZpZy5vcmllbnRhdGlvbjtcbiAgICB0aGlzLnJvbGVzID0gY29uZmlnLnJvbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYXYgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYmVmb3JlIHRoZSBuYXYgY2hhbmdlIGhhcHBlbnMgb24gdXNlciBjbGljay5cbiAgICpcbiAgICogVGhpcyBldmVudCB3b24ndCBiZSBlbWl0dGVkIGlmIG5hdiBpcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkgdmlhIGBbYWN0aXZlSWRdYCBvciBgLnNlbGVjdCgpYC5cbiAgICpcbiAgICogU2VlIFtgTmdiTmF2Q2hhbmdlRXZlbnRgXSgjL2NvbXBvbmVudHMvbmF2L2FwaSNOZ2JOYXZDaGFuZ2VFdmVudCkgZm9yIHBheWxvYWQgZGV0YWlscy5cbiAgICovXG4gIEBPdXRwdXQoKSBuYXZDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPE5nYk5hdkNoYW5nZUV2ZW50PigpO1xuXG4gIGNsaWNrKGl0ZW06IE5nYk5hdkl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZUlkKGl0ZW0uaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSBuYXYgd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIHNob3dzIGl0cyBhc3NvY2lhdGVkIHBhbmUuXG4gICAqIEFueSBvdGhlciBuYXYgdGhhdCB3YXMgcHJldmlvdXNseSBzZWxlY3RlZCBiZWNvbWVzIHVuc2VsZWN0ZWQgYW5kIGl0cyBhc3NvY2lhdGVkIHBhbmUgaXMgaGlkZGVuLlxuICAgKi9cbiAgc2VsZWN0KGlkOiBhbnkpIHsgdGhpcy5fdXBkYXRlQWN0aXZlSWQoaWQsIGZhbHNlKTsgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLmFjdGl2ZUlkKSkge1xuICAgICAgY29uc3QgbmV4dElkID0gdGhpcy5pdGVtcy5maXJzdCA/IHRoaXMuaXRlbXMuZmlyc3QuaWQgOiBudWxsO1xuICAgICAgaWYgKGlzVmFsaWROYXZJZChuZXh0SWQpKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZUlkKG5leHRJZCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdXBkYXRlQWN0aXZlSWQobmV4dElkOiBhbnksIGVtaXROYXZDaGFuZ2UgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlSWQgIT09IG5leHRJZCkge1xuICAgICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGVtaXROYXZDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5uYXZDaGFuZ2UuZW1pdCh7YWN0aXZlSWQ6IHRoaXMuYWN0aXZlSWQsIG5leHRJZCwgcHJldmVudERlZmF1bHQ6ICgpID0+IHsgZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7IH19KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSWQgPSBuZXh0SWQ7XG4gICAgICAgIHRoaXMuYWN0aXZlSWRDaGFuZ2UuZW1pdChuZXh0SWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogQSBkaXJlY3RpdmUgdG8gcHV0IG9uIHRoZSBuYXYgbGluay5cbiAqXG4gKiBAc2luY2UgNS4yLjBcbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnYVtuZ2JOYXZMaW5rXScsXG4gIGhvc3Q6IHtcbiAgICAnW2lkXSc6ICduYXZJdGVtLmRvbUlkJyxcbiAgICAnW2NsYXNzLm5hdi1saW5rXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLm5hdi1pdGVtXSc6ICdoYXNOYXZJdGVtQ2xhc3MoKScsXG4gICAgJ1thdHRyLnJvbGVdJzogYHJvbGUgPyByb2xlIDogbmF2LnJvbGVzID8gJ3RhYicgOiB1bmRlZmluZWRgLFxuICAgICdocmVmJzogJycsXG4gICAgJ1tjbGFzcy5hY3RpdmVdJzogJ25hdkl0ZW0uYWN0aXZlJyxcbiAgICAnW2NsYXNzLmRpc2FibGVkXSc6ICduYXZJdGVtLmRpc2FibGVkJyxcbiAgICAnW2F0dHIudGFiaW5kZXhdJzogJ25hdkl0ZW0uZGlzYWJsZWQgPyAtMSA6IHVuZGVmaW5lZCcsXG4gICAgJ1thdHRyLmFyaWEtY29udHJvbHNdJzogJ25hdkl0ZW0uaXNQYW5lbEluRG9tKCkgPyBuYXZJdGVtLnBhbmVsRG9tSWQgOiBudWxsJyxcbiAgICAnW2F0dHIuYXJpYS1zZWxlY3RlZF0nOiAnbmF2SXRlbS5hY3RpdmUnLFxuICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICduYXZJdGVtLmRpc2FibGVkJyxcbiAgICAnKGNsaWNrKSc6ICduYXYuY2xpY2sobmF2SXRlbSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE5nYk5hdkxpbmsge1xuICBjb25zdHJ1Y3RvcihAQXR0cmlidXRlKCdyb2xlJykgcHVibGljIHJvbGU6IHN0cmluZywgcHVibGljIG5hdkl0ZW06IE5nYk5hdkl0ZW0sIHB1YmxpYyBuYXY6IE5nYk5hdikge31cblxuICBoYXNOYXZJdGVtQ2xhc3MoKSB7XG4gICAgLy8gd2l0aCBhbHRlcm5hdGl2ZSBtYXJrdXAgd2UgaGF2ZSB0byBhZGQgYC5uYXYtaXRlbWAgY2xhc3MsIGJlY2F1c2UgYG5nYk5hdkl0ZW1gIGlzIG9uIHRoZSBuZy1jb250YWluZXJcbiAgICByZXR1cm4gdGhpcy5uYXZJdGVtLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5DT01NRU5UX05PREU7XG4gIH1cbn1cblxuXG4vKipcbiAqIFRoZSBwYXlsb2FkIG9mIHRoZSBjaGFuZ2UgZXZlbnQgZW1pdHRlZCByaWdodCBiZWZvcmUgdGhlIG5hdiBjaGFuZ2UgaGFwcGVucyBvbiB1c2VyIGNsaWNrLlxuICpcbiAqIFRoaXMgZXZlbnQgd29uJ3QgYmUgZW1pdHRlZCBpZiBuYXYgaXMgY2hhbmdlZCBwcm9ncmFtbWF0aWNhbGx5IHZpYSBgW2FjdGl2ZUlkXWAgb3IgYC5zZWxlY3QoKWAuXG4gKlxuICogQHNpbmNlIDUuMi4wXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmdiTmF2Q2hhbmdlRXZlbnQge1xuICAvKipcbiAgICogSWQgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgbmF2LlxuICAgKi9cbiAgYWN0aXZlSWQ6IGFueTtcblxuICAvKipcbiAgICogSWQgb2YgdGhlIG5ld2x5IHNlbGVjdGVkIG5hdi5cbiAgICovXG4gIG5leHRJZDogYW55O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgcHJldmVudCBuYXYgY2hhbmdlIGlmIGNhbGxlZC5cbiAgICovXG4gIHByZXZlbnREZWZhdWx0OiAoKSA9PiB2b2lkO1xufVxuIl19